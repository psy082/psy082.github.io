<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JS Function과 Arrow Function - dev&#039;log</title><meta description="Dave&amp;#39;s blog"><meta property="og:type" content="blog"><meta property="og:title" content="JS Function과 Arrow Function"><meta property="og:url" content="http://psy082.github.io/"><meta property="og:site_name" content="dev&#039;log"><meta property="og:description" content="Dave&amp;#39;s blog"><meta property="og:locale" content="ko_KR"><meta property="article:published_time" content="2020-06-11T01:55:00.000Z"><meta property="article:modified_time" content="2020-06-12T12:06:44.142Z"><meta property="article:author" content="Dave Kim"><meta property="article:tag" content="JS"><meta property="article:tag" content="function"><meta property="article:tag" content="arrow function"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://psy082.github.io/img/default/dev_logo.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://psy082.github.io/2020/06/11/js-function/"},"headline":"dev'log","image":["http://psy082.github.io/img/post/JavaScriptImg.png"],"datePublished":"2020-06-11T01:55:00.000Z","dateModified":"2020-06-12T12:06:44.142Z","author":{"@type":"Person","name":"Dave Kim"},"description":"앞의 글에서는 JS가 lexical scope을 사용하는 언어인데도 불구하고 왜 this가 함수 실행 때 binding되는지 문제제기 했다. 또한 lexical scope와 dynamic scope에 대해서, lexical scope임에도 동적으로 함수가 생성되는 특징 때문에 생겨나는 closure에 대해 다루었다. 이번 글에서는 function과 arro"}</script><link rel="canonical" href="http://psy082.github.io/2020/06/11/js-function/"><link rel="icon" href="/img/default/web-development.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-163248250-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-163248250-1');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/default/dev_logo.jpeg" alt="dev&#039;log" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/psy082/psy082.git"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="/img/post/JavaScriptImg.png" alt="JS Function과 Arrow Function"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-11T01:55:00.000Z" title="2020-06-11T01:55:00.000Z">2020-06-11</time><span class="level-item"><a class="link-muted" href="/categories/programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/programming/javascript/">JavaScript</a></span></div></div><h1 class="title is-3 is-size-4-mobile">JS Function과 Arrow Function</h1><div class="content"><p>앞의 글에서는 JS가 lexical scope을 사용하는 언어인데도 불구하고 왜 this가 함수 실행 때 binding되는지 문제제기 했다. 또한 lexical scope와 dynamic scope에 대해서, lexical scope임에도 동적으로 함수가 생성되는 특징 때문에 생겨나는 closure에 대해 다루었다. 이번 글에서는 function과 arrow function의 실행을 다루면서 왜 this가 실행 때 binding되는지와 closure를 사용함으로써 function과 arrow function의 this가 어떻게 달라지는 지 알아보도록 하겠다.</p>
<a id="more"></a>

<h2 id="그래서-this는-실행-시에-binding되는거야"><a href="#그래서-this는-실행-시에-binding되는거야" class="headerlink" title="그래서 this는 실행 시에 binding되는거야?"></a>그래서 this는 실행 시에 binding되는거야?</h2><p>사실 이번에 다루는 주제 또한 JS에서는 함수 또한 Object 객체로부터 만들어진 객체라는 지식과, 객체 간 prototype chain을 통해 이루어 지는 유사 상속에 대한 사전 지식이 필요하다. 하지만 해당 주제들은 단일 주제로 다루어야 할만큼 꽤 많은 내용이기 때문에 해당 내용을 안다는 전제 하에 설명을 하겠다.(사실 쉽고 간결하게 설명할 역량이 부족합니다…) </p>
<p>※ 함수 또한 Object 객체로부터 만들어진 객체라는 사실은 함수를 생성한 후에 생성된 함수의 prototype 값을 확인해 보면 <strong>proto</strong>값이 Object라는 사실로 확인할 수 있다.</p>
<ul>
<li>this example</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a); <span class="hljs-comment">// this points for what?</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>  a: <span class="hljs-number">10</span>,<br>  foo: foo<br>&#125;<br><br>foo();                <span class="hljs-comment">//undefined</span><br>bar.foo();            <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure>

<br>
위의 예제는 지난 글에서 다루었던 예제이다. 위의 예제를 보면 마치 함수 foo에는 this 값이 없어서 this 값을 외부에서 찾아야 할 것 같아 보인다. 그런데 사실은 그렇지 않다. 우리는 JS에서 함수가 실행될 때 주어진 변수만 받아서 쭉 실행되는 것처럼 생각하지만 사실 JS의 함수는 그렇게 동작하지 않는다.

<h2 id="JS에서-함수가-동작하는-방식"><a href="#JS에서-함수가-동작하는-방식" class="headerlink" title="JS에서 함수가 동작하는 방식"></a>JS에서 함수가 동작하는 방식</h2><p>JS에서 함수가 동작하는 방식을 이해하려면 앞서 언급했던 JS에서는 함수도 객체라는 사실을 기억해야 한다. JS에서 함수가 생성될 때는 JS 내부적으로 Function constructor가 함수를 생성한다. contructor가 함수를 생성할 때는 함수 내부에 즉시 prototype이라는 key를 만들고 오브젝트를 할당한다. 그 다음 prototype 오브젝트에 constructor라는 키를 잡고, 함수 자신의 참조 값을 저장한다. 따라서 JS에서 생성된 함수는 다른 언어에서의 함수와는 다르게 그 자체가 객체인 것이다. 아래의 예제는 함수 생성 과정을 간단히 설명한 예제이다. JS내부에서는 아래의 예제의 과정이 자동적으로 이루어진다.</p>
<ul>
<li>JS 함수 생성 과정</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//함수가 생성되면</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-comment">//1. 즉시 prototype이라는 키에 오브젝트가 할당되고</span><br>test.prototype = &#123;&#125;;<br><br><span class="hljs-comment">//2. contructor에 함수 자신의 참조 값을 저장한다</span><br>test.prototype.constructor = test<br><span class="hljs-comment">//출처: 클래스 기반 언어 vs 자바스크립트 1/3</span><br><span class="hljs-comment">//(https://www.bsidesoft.com/318)</span><br></code></pre></td></tr></table></figure>

<br>

<p>그러면 위의 과정으로 만들어진 함수는 JS Function 객체 prototype의 모든 메소드들에 접근할 수 있고, 사용할 수도 있다. 그리고 JS 함수는 함수를 실행할 때 Function.prototype.call함수를 사용해서 실행한다</p>
<h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call"></a>Function.prototype.call</h2><ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 문서 Function.prototype.call</a> 구문 정의</li>
</ul>
<blockquote>
<p>func.call(thisArg[, arg1[, arg2[, …]]]) </p>
</blockquote>
<p>Function.prototype 메소드들이 여러가지 있지만, JS에서 함수를 실행 할 때는 내부적으로 Function.prototype.call에 의해 이루어 진다. Function.prototype.call은 두 종류의 인자를 받는다. 첫번째로 받는 인자는 thisArg로 객체의 참조 값을 받는다. 두번째로 받는 인자는 함수의 인자들을 배열로 묶은 argList이다. 실제로 console에서 arguments를 확인해보면 각각의 인자들을 확인해볼 수 있다.</p>
<ul>
<li>함수 인자 확인</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a, b, c</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>], <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]);<br>&#125;<br><br>test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 1, 2, 3</span><br></code></pre></td></tr></table></figure>

<br>
이를 통해 알 수 있는 사실은 함수에서 this값은 binding되는 게 아니라 인자로 주어진다는 것이다. 위의 예제에서 test함수는 a, b, c 세가지의 인자만 받는 것이라고 생각하지만, 실제 실행 시에는 Function.prototype.call이 사용되며 자동으로 현재 객체의 참조 값이 thisArg로 전달된다. 따라서 this는 lexical scope의 예외가 아니다. this 값은 함수 내부적으로 주어지는 값이다.

<ul>
<li>this example</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a); <span class="hljs-comment">// this points for what?</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>  a: <span class="hljs-number">10</span>,<br>  foo: foo<br>&#125;<br><br>foo();                <span class="hljs-comment">//undefined</span><br>bar.foo();            <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure>

<br>
위의 예제를 다시 보면 foo 함수가 실행될 때, Function.prototype.call에 this 값으로 전역 객체 window가 주어지는 반면 bar.foo 함수가 실행될 때는 foo함수의 this값으로 bar객체의 참조 값이 주어진다. 이제 this에 대한 의문이 풀렸다. 함수의 this가 실행 시의 객체인 이유는 dynamic binding이기 때문이 아니라 함수 내부적으로 this 값이 인자로 전달 되기 때문이다.

<h2 id="Arrow-Function"><a href="#Arrow-Function" class="headerlink" title="Arrow Function"></a>Arrow Function</h2><p>그런데 내부적으로 this값을 주는 방식으로 함수가 실행되었을 때 불편한 점이 있다.</p>
<ul>
<li>this 값으로 전역객체가 주어질 때</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// Person() 생성자는 `this`를 자신의 인스턴스로 정의.</span><br>  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;<br><br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">growUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 비엄격 모드에서, growUp() 함수는 `this`를</span><br>    <span class="hljs-comment">// 전역 객체로 정의하고, 이는 Person() 생성자에</span><br>    <span class="hljs-comment">// 정의된 `this`와 다름.</span><br>    <span class="hljs-keyword">this</span>.age++;<br>  &#125;)();<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(p.age);   <span class="hljs-comment">//0</span><br><span class="hljs-comment">//출처: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98 (mdn예제를 일부 수정)</span><br></code></pre></td></tr></table></figure>

<br>
위의 예제를 보자. Person 생성자 함수가 있고 생성자 함수 안에는 즉시 실행함수 growUp이 this의 age값을 1 증가 시킨다. 문제는 growUp함수에 입력되는 this 값은 Person의 this 값이 아니다. JS에서 함수들은 객체에서 실행되지 않는다면 this값으로 window객체가 주어진다. 따라서 growUp함수에서 사용하는 this는 Person의 인스턴스가 아니라 전역객체 window이다. 그래서 p.age를 출력해보면 age값이 변하지 않고 그대로 0이 출력된다.

<ul>
<li>closure 을 이용한 this binding</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;  <br>  that.age = <span class="hljs-number">0</span>;<br><br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">growUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 콜백은  `that` 변수를 참조하고 이것은 값이 기대한 객체이다.</span><br>    that.age++;<br>  &#125;)()<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(p.age);   <span class="hljs-comment">//1</span><br><span class="hljs-comment">//출처: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98 (mdn예제를 일부 수정)</span><br></code></pre></td></tr></table></figure>

<br>
그러면 growUp함수에서 Person 인스턴스를 사용할 수 있는 방법이 없는 것인가? 그렇지 않다. JS의 특징인 closure를 사용하여 우회적으로 사용할 수 있다. 위의 예제를 보면 Person 생성자 함수가 인스턴스 참조 값인 this를 that 변수에 저장한다.  growUp 함수는 that 변수가 없기 때문에 자신이 생성되었을 때의 환경에서 자유변수들을 탐색한다. Person 생성자 함수 안에서 Person 인스턴스 참조가 저장된 that 변수를 발견했기 때문에 that.age를 1 증가시킨다. 따라서 p.age를 출력해보면 1이 출력되는 것을 확인할 수 있다. 그런데 위의 방식으로 일일이 인스턴스 참조값을 따로 저장해서 사용하는 방식은 불편하다. 그래서 es6부터는 arrow function이 생겼다.

<h3 id="arrow-function"><a href="#arrow-function" class="headerlink" title="arrow function"></a>arrow function</h3><ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this">MDN 문서 this 설명 일부</a></li>
</ul>
<blockquote>
<p>… EC2015는 스스로의 this 바인딩을 제공하지 않는 화살표 함수를 추가했습니다(이는 렉시컬 컨텍스트안의 this값을 유지합니다).</p>
</blockquote>
<p>this 문서를 보면 arrow function은 스스로의 this 바인딩을 제공하지 않는다고 설명한다. 이는 기존의 일반 함수들이 내부적으로 Function.prototype.call을 실행하여 this를 인자로 넘기는 방식으로 작동하지 않는다는 의미다. 괄호 설명을 보면 arrow function이 렉시컬 컨텍스트 안의 this 값을 유지한다고 말하는데, arrow function 문서에서는 arrow function이 렉시컬 컨텍스트 안의 this 값을 유지한다는 말을 다른 말로 설명했다.</p>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98">MDN 문서 arrow function 설명 일부</a></li>
</ul>
<blockquote>
<p>화살표 함수는 전역 컨텍스트에서 실행될 때 this를 새로 정의하지 않습니다. 대신 코드에서 바로 바깥의 함수(혹은 class)의 this값이 사용됩니다. 이것은 this를 클로저 값으로 처리하는 것과 같습니다. …</p>
</blockquote>
<p>즉, arrow function의 경우에는 인자로 this가 주어지지 않기 때문에 앞의 예제에서처럼 closure를 사용해 this를 binding하는 것과 동일하게 작동하는 것이다. 이때문에 arrow function은 call, apply를 사용해서 this 값을 인자로 넘겨줘도 넘겨 받은 this를 사용하지 않고 closure의 this를 사용한다. 아래의 arrow function을 사용한 예제를 보면 앞에서 closure를 사용해 this를 binding했을 때와 동일하게 작동하는 것을 확인할 수 있다.</p>
<ul>
<li>arrow function을 사용한 this binding</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;<br><br>  (<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// arrow function은 closure에 있는 this값을 사용한다.</span><br>    <span class="hljs-keyword">this</span>.age++;<br>  &#125;)()<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(p.age);   <span class="hljs-comment">//1</span><br><span class="hljs-comment">//출처: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98 (mdn예제를 일부 수정)</span><br></code></pre></td></tr></table></figure>

<br>
<br>

<p>정리</p>
<ul>
<li><p>JS에서 일반 함수들은 내부적으로 Function.prototype.call함수를 통해 실행된다.</p>
</li>
<li><p>Function.prototype.call함수를 통해 실행될 때 this값과 arguments들이 인자로 주어진다.</p>
</li>
<li><p>따라서 JS에서 this가 실행 시에 결정되는 이유는 dynamic binding처럼 작동하기 때문이 아니라 실행 시에 인자로 주어지기 때문이다.</p>
</li>
<li><p>그런데 위와 같이 작동하는 경우 함수 내의 함수는 this 값으로 자신을 생성한 함수를 받지 못하고 전역객체 window를 받는다.(비엄격모드일 때라는 조건이 있다.)</p>
</li>
<li><p>이럴 경우 내부 함수는 closure를 사용하여 this 값을 우회적으로 받아야 한다.</p>
</li>
<li><p>arrow 함수는 this가 내부적으로 binding되지 않고 closure 값을 사용하는 것처럼 this가 binding 된다.</p>
</li>
</ul>
<p>참고자료</p>
<ul>
<li><a href="https://velog.io/@imacoolgirlyo/JS-JavaScript-Function-Invocation%EC%99%80-this">자바스크립트의 Function 호출과 this</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this">MDN this 문서</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98">MDN arrow function 문서</a></li>
</ul>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/js/">JS</a><a class="link-muted mr-2" rel="tag" href="/tags/function/">function</a><a class="link-muted mr-2" rel="tag" href="/tags/arrow-function/">arrow function</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/15/til-1st/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Til 1일차</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/08/js-closure/"><span class="level-item">JS Lexical Scope와 Closure</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://psy082.github.io/2020/06/11/js-function/';
            this.page.identifier = '2020/06/11/js-function/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'davlog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><a class="media-left" href="/2021/09/26/codesum-week-6/"><p class="image is-64x64"><img class="thumbnail" src="/img/post/weekly_review.png" alt="코드숨 React 5기 - 6주차 회고"></p></a><div class="media-content size-small"><p><time dateTime="2021-09-26T14:10:00.000Z">2021-09-26</time></p><p class="title is-6"><a class="link-muted" href="/2021/09/26/codesum-week-6/">코드숨 React 5기 - 6주차 회고</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/til/">TIL</a></p></div></article><article class="media"><a class="media-left" href="/2021/09/13/codesum-week-5/"><p class="image is-64x64"><img class="thumbnail" src="/img/post/weekly_review.png" alt="코드숨 React 5기 - 5주차 회고"></p></a><div class="media-content size-small"><p><time dateTime="2021-09-13T14:10:00.000Z">2021-09-13</time></p><p class="title is-6"><a class="link-muted" href="/2021/09/13/codesum-week-5/">코드숨 React 5기 - 5주차 회고</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/til/">TIL</a></p></div></article><article class="media"><a class="media-left" href="/2021/09/06/codesum-week-4/"><p class="image is-64x64"><img class="thumbnail" src="/img/post/weekly_review.png" alt="코드숨 React 5기 - 4주차 회고"></p></a><div class="media-content size-small"><p><time dateTime="2021-09-06T14:10:00.000Z">2021-09-06</time></p><p class="title is-6"><a class="link-muted" href="/2021/09/06/codesum-week-4/">코드숨 React 5기 - 4주차 회고</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/til/">TIL</a></p></div></article><article class="media"><a class="media-left" href="/2021/08/29/codesum-week-3/"><p class="image is-64x64"><img class="thumbnail" src="/img/post/weekly_review.png" alt="코드숨 React 5기 - 3주차 회고"></p></a><div class="media-content size-small"><p><time dateTime="2021-08-29T08:55:00.000Z">2021-08-29</time></p><p class="title is-6"><a class="link-muted" href="/2021/08/29/codesum-week-3/">코드숨 React 5기 - 3주차 회고</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/til/">TIL</a></p></div></article><article class="media"><a class="media-left" href="/2021/08/22/codesum-week-2/"><p class="image is-64x64"><img class="thumbnail" src="/img/post/weekly_review.png" alt="코드숨 React 5기 - 2주차 회고"></p></a><div class="media-content size-small"><p><time dateTime="2021-08-22T08:55:00.000Z">2021-08-22</time></p><p class="title is-6"><a class="link-muted" href="/2021/08/22/codesum-week-2/">코드숨 React 5기 - 2주차 회고</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/til/">TIL</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/programming/css/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/programming/html/"><span class="level-start"><span class="level-item">HTML</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/programming/javascript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/programming/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/programming/%EA%B8%B0%ED%83%80/"><span class="level-start"><span class="level-item">기타</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/til/"><span class="level-start"><span class="level-item">TIL</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%EA%B0%9C%EC%9D%B8%EC%A0%81%EC%9D%B8/"><span class="level-start"><span class="level-item">개인적인</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%EA%B0%9C%EC%9D%B8%EC%A0%81%EC%9D%B8/%EB%AC%B5%EC%83%81/"><span class="level-start"><span class="level-item">묵상</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%EA%B0%9C%EC%9D%B8%EC%A0%81%EC%9D%B8/%EC%97%90%EC%84%B8%EC%9D%B4/"><span class="level-start"><span class="level-item">에세이</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/default/dev_logo.jpeg" alt="dev&#039;log" height="28"></a><p class="size-small"><span>&copy; 2021 Dave Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/psy082/psy082.git"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://psy082.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Zurück nach oben" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(Untitled)","posts":"포스트","pages":"Pages","categories":"카테고리","tags":"태그"});
        });</script></body></html>